# Взаимодействие сервисов

## Обзор сервисов

Проект состоит из четырех основных сервисов:

- **Backend API Service** - основной сервис, предоставляющий REST API для управления пользователями, конфигурациями, сессиями и административными функциями
- **Frontend Service** - веб-приложение на React, предоставляющее пользовательский интерфейс
- **Notificator Service** - фоновый сервис для обработки и отправки уведомлений пользователям
- **Telegram Bot Service** - Telegram бот для интеграции с веб-приложением через Web App

Все сервисы взаимодействуют через общую базу данных PostgreSQL и Redis (для кэширования и rate limiting).

## Backend API Service

### Основные функции

Backend API Service - это FastAPI приложение, которое предоставляет REST API для всех операций системы:

- **Аутентификация и авторизация**: регистрация, вход, управление сессиями, JWT токены (подробнее см. [документацию по аутентификации](authentication.md))
- **Управление пользователями**: профили, верификация, управление ролями (подробнее см. [документацию по ролям](roles.md))
- **Управление конфигурациями**: создание, обновление, продление конфигураций VPN (VLESS, TROJAN)
- **Административные функции**: управление пользователями, конфигурациями, запросами, новостями
- **Интеграция с XUI**: синхронизация конфигураций с 3X-UI панелью
- **Управление настройками приложения**: настройки системы, включение/выключение регистрации

### Зависимости

- **PostgreSQL** - основная база данных для хранения всех данных
- **Redis** (основной) - кэширование JWT токенов, сессий
- **Redis** (rate limiter) - отдельный экземпляр для rate limiting
- **3X-UI** - внешний сервис для управления VPN конфигурациями (на отдельном сервере)

### Взаимодействие с базой данных

Backend использует SQLAlchemy (asyncpg) для работы с PostgreSQL. Все операции выполняются через сервис `DbService`, который предоставляет:

- Транзакции для атомарных операций
- CRUD операции для всех моделей
- Фильтрация, пагинация, сортировка
- Управление сессиями подключения

### Взаимодействие с Redis

Backend использует два экземпляра Redis:

1. **Основной Redis** (`REDIS_*`):
   - Хранение JWT access токенов для быстрой валидации
   - Кэширование данных сессий
   - TTL токенов настраивается через `ACCESS_TOKEN_REDIS_TTL_SEC` и `REFRESH_TOKEN_REDIS_TTL_SEC`

2. **Redis Rate Limiter** (`RATE_LIMIT_REDIS_*`):
   - Отслеживание количества запросов по IP-адресам
   - Глобальный rate limiting через middleware `GlobalRateLimitMiddleware`
   - Настраиваемые лимиты через `DEFAULT_REQUESTS_PER_MINUTE`

### API endpoints

Backend предоставляет следующие группы endpoints:

- `/api/app/v1/*` - публичные endpoints (health, settings)
- `/api/auth/v1/*` - аутентификация и управление аккаунтом
- `/api/backend/v1/*` - endpoints для пользователей (конфигурации, новости)
- `/api/admin/v1/*` - административные endpoints (требуют роль ADMIN или SUPERUSER)

Подробное описание endpoints см. в [API документации](api.md). Распределение прав доступа по endpoints описано в [документации по ролям](roles.md).

## Frontend Service

### Основные функции

Frontend Service - это React приложение на TypeScript, собранное с помощью Vite:

- **Пользовательский интерфейс**: страницы для регистрации, входа, управления конфигурациями, профилем
- **Административная панель**: управление пользователями, конфигурациями, запросами, новостями (для ADMIN/SUPERUSER)
- **Интеграция с Telegram**: поддержка Telegram WebApp для авторизации через Telegram
- **Многоязычность**: поддержка русского и английского языков (i18n)
- **Управление состоянием**: Zustand store для глобального состояния приложения

### Взаимодействие с Backend API

Frontend взаимодействует с Backend через HTTP API:

- **API Client** (`services/api/api.ts`): централизованный клиент для всех API запросов пользователей
- **Admin API Client** (`services/api/admin.ts`): отдельный клиент для административных операций
- **Вечная сессия**: refresh token хранится в localStorage (персистентно), access token в sessionStorage, что обеспечивает сохранение сессии между перезагрузками страницы
- **Скользящее обновление токенов**: клиент автоматически обновляет access token при приближении к истечению (проверка перед каждым запросом), а также при получении 401. При успешном обновлении выдается новая пара токенов (access + refresh), что продлевает сессию и создает эффект "скользящего окна" - пока пользователь активен, сессия не истекает
- **Обработка ошибок**: централизованная обработка ошибок авторизации и валидации
- **Типизация**: полная типизация всех запросов и ответов через TypeScript

### Управление состоянием

Frontend использует Zustand для управления глобальным состоянием:

- **useAppStore**: хранит информацию о текущем пользователе, токенах, настройках
- **Автоматическая синхронизация**: состояние синхронизируется с токенами в localStorage
- **Реактивность**: компоненты автоматически обновляются при изменении состояния

### Роутинг

Роутинг реализован через React Router:

- Публичные маршруты: `/`, `/login`, `/register`
- Защищенные маршруты: `/configs`, `/account` (требуют аутентификации)
- Административные маршруты: `/admin/*` (требуют роль ADMIN или SUPERUSER)
- Защита маршрутов через компонент `ProtectedRoute`

Подробнее о ролях и правах доступа см. [документацию по ролям](roles.md).

## Notificator Service

### Основные функции

Notificator Service - это фоновый Python сервис, который периодически проверяет и отправляет уведомления:

- **Проверка истекающих конфигураций**: автоматическое создание уведомлений для конфигураций, которые скоро истекают
- **Отправка уведомлений**: отправка уведомлений через Telegram и другие социальные сети
- **Очистка старых уведомлений**: автоматическое удаление уведомлений старше заданного периода

### Обработка уведомлений

Сервис работает в цикле с настраиваемым интервалом (`PROCESS_PERIOD_SEC`): проверка истекающих конфигураций, получение непрочитанных уведомлений из базы данных, отправка уведомлений через соответствующие каналы, повторная отправка неудачных уведомлений и очистка старых уведомлений.

### Проверка истекающих конфигураций

Сервис проверяет конфигурации, которые истекают в течение заданного периода (`CONFIG_EXPIRY_NOTIF_HOURS`):

- Находит конфигурации с `valid_to_dttm` в ближайшие N часов
- Проверяет, что для конфигурации еще не создано уведомление
- Создает уведомления с многоязычным содержимым (русский/английский)
- Сохраняет уведомления в базу данных со статусом `new`

### Отправка уведомлений

Сервис отправляет уведомления через различные каналы:

- **Telegram**: отправка через Telegram Bot API с кнопкой для открытия Web App
- **Yandex**: поддержка отправки через Yandex (если реализовано)
- Многоязычность: уведомления отправляются на языке пользователя (из `profile.lang_code`)

После успешной отправки уведомление обновляется с указанием канала отправки и времени.

### Обработка ошибок

- Неудачные отправки логируются и повторяются в следующей итерации
- Ошибки подключения к базе данных обрабатываются с логированием
- Graceful shutdown при получении SIGINT/SIGTERM

### Взаимодействие с базой данных

Notificator использует asyncpg для прямого подключения к PostgreSQL:

- Чтение уведомлений из таблицы `notification`
- Чтение конфигураций из таблицы `config`
- Чтение профилей пользователей для определения языка
- Обновление статуса отправки уведомлений

### Взаимодействие с Telegram Bot

Notificator использует aiogram для отправки сообщений через Telegram Bot:

- Отправка текстовых сообщений с кнопками
- Интеграция с Web App через `WebAppInfo`
- Обработка ошибок отправки (пользователь заблокировал бота и т.д.)

## Telegram Bot Service

### Основные функции

Telegram Bot Service - это простой Telegram бот на aiogram, который предоставляет точку входа в веб-приложение:

- **Команда /start**: приветственное сообщение с кнопкой для открытия Web App
- **Web App интеграция**: кнопка открывает веб-приложение в Telegram
- **Многоязычность**: автоматическое определение языка пользователя (русский/английский)

### Команды бота

- `/start` - основная команда, отправляет приветственное сообщение с кнопкой для открытия Web App

### Web App интеграция

Бот использует Telegram Web App API:

- Кнопка с `WebAppInfo` указывает на URL веб-приложения (`WEB_APP_URL`)
- При нажатии кнопки Telegram открывает веб-приложение в встроенном браузере
- Веб-приложение может использовать Telegram WebApp API для получения данных пользователя

### Взаимодействие с Frontend

Бот не взаимодействует напрямую с Frontend, но предоставляет точку входа:

1. Пользователь нажимает `/start` в боте
2. Бот отправляет сообщение с кнопкой Web App
3. Пользователь нажимает кнопку, открывается веб-приложение
4. Frontend использует Telegram WebApp API для получения данных пользователя
5. Frontend отправляет данные на Backend для авторизации через `/api/auth/v1/login/social/telegram`

## Обмен данными между сервисами

### HTTP API

Основной способ взаимодействия между Frontend и Backend:

- **Протокол**: HTTP/HTTPS
- **Формат данных**: JSON
- **Аутентификация**: JWT токены в заголовке `Authorization: Bearer <token>`
- **CORS**: настроен для разрешенных доменов

### База данных

Все сервисы используют общую базу данных PostgreSQL:

- **Backend**: основная работа с БД через SQLAlchemy
- **Notificator**: прямое подключение через asyncpg для чтения/записи уведомлений
- **Схема БД**: единая схема для всех сервисов, миграции управляются Backend

Подробное описание моделей данных см. в [документации по моделям данных](data-models.md).

### Redis

Backend использует Redis для:

- **Кэширование JWT токенов**: быстрая валидация access токенов без обращения к БД (подробнее см. [документацию по аутентификации](authentication.md))
- **Rate limiting**: отслеживание количества запросов по IP
- **TTL токенов**: автоматическое истечение токенов через Redis TTL

Notificator и Telegram Bot не используют Redis напрямую.

### Очереди сообщений

В текущей реализации очереди сообщений не используются. Notificator работает в цикле и проверяет БД напрямую.

## Схемы взаимодействия

Подробное описание процессов аутентификации и работы с токенами см. в [документации по аутентификации](authentication.md).

### Регистрация и вход пользователя

1. **Обычная регистрация**:
   - Frontend → Backend: `POST /api/auth/v1/register`
   - Backend создает пользователя, профиль, роль USER
   - Backend → Frontend: JWT токены (access + refresh)

2. **Вход через Telegram**:
   - Пользователь нажимает `/start` в Telegram Bot
   - Бот отправляет кнопку Web App
   - Frontend получает данные через Telegram WebApp API
   - Frontend → Backend: `POST /api/auth/v1/login/social/telegram`
   - Backend проверяет hash, создает/находит пользователя
   - Backend → Frontend: JWT токены

3. **Вход с логином/паролем**:
   - Frontend → Backend: `POST /api/auth/v1/login`
   - Backend проверяет пароль, создает сессию
   - Backend → Frontend: JWT токены

### Создание конфигурации

1. Пользователь создает конфигурацию через Backend API
2. Backend синхронизирует конфигурацию с 3X-UI
3. Backend сохраняет конфигурацию в БД
4. Пользователь видит конфигурацию через Frontend

### Отправка уведомлений

1. **Создание уведомления**:
   - Backend создает уведомление в БД (например, при создании запроса)
   - Notificator периодически проверяет новые уведомления

2. **Проверка истекающих конфигураций**:
   - Notificator проверяет конфигурации, которые скоро истекают
   - Создает уведомления для пользователей

3. **Отправка**:
   - Notificator получает уведомления из БД
   - Отправляет через Telegram Bot API
   - Обновляет статус отправки в БД

### Управление сессиями

Подробное описание работы с сессиями и токенами см. в [документации по аутентификации](authentication.md).

1. **Создание сессии**:
   - При входе Backend создает сессию в БД
   - Сохраняет access token в Redis с TTL
   - Возвращает токены Frontend

2. **Валидация токена**:
   - Frontend отправляет запрос с access token
   - Backend проверяет токен в Redis (быстро)
   - Если токена нет в Redis, проверяет в БД

3. **Обновление токена**:
   - Frontend отправляет refresh token
   - Backend проверяет refresh token в БД
   - Создает новую сессию и токены

4. **Завершение сессии**:
   - Backend удаляет токен из Redis
   - Помечает сессию как неактивную в БД

## Обработка ошибок

### Типы ошибок

Все сервисы используют стандартизированные HTTP статус коды:

- **400 Bad Request**: ошибки валидации данных
- **401 Unauthorized**: отсутствие или невалидный токен
- **403 Forbidden**: недостаточно прав доступа
- **404 Not Found**: ресурс не найден
- **409 Conflict**: конфликт данных (например, пользователь уже существует)
- **422 Unprocessable Entity**: ошибки бизнес-логики
- **500 Internal Server Error**: внутренние ошибки сервера

Backend использует кастомные исключения (`src/core/exceptions.py`) для единообразной обработки ошибок. Подробное описание типов ошибок и их кодов см. в [API документации](api.md).

### Логирование

Все сервисы используют структурированное логирование:

- **Backend**: Python logging с настраиваемым уровнем (DEBUG/INFO/ERROR)
- **Notificator**: Python logging с детальным логированием операций
- **Telegram Bot**: Python logging для команд и ошибок
- **Frontend**: console.log для разработки (в production можно использовать внешний сервис)

### Мониторинг

- **Health check**: Backend предоставляет `/api/app/v1/health` для проверки статуса
- **Status endpoint**: `/api/app/v1/status` показывает статус всех зависимостей (DB, Redis, XUI)
- **Логи**: все сервисы логируют важные события и ошибки
