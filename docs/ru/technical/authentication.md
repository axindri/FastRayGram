# Аутентификация и авторизация

## Обзор системы аутентификации

Система использует JWT (JSON Web Tokens) для аутентификации. При входе пользователь получает пару токенов: access token (короткоживущий) и refresh token (долгоживущий). Все токены хранятся в Redis для быстрой проверки и возможности отзыва.

## JWT токены

### Access Token

Access token используется для доступа к защищенным endpoints. Имеет ограниченное время жизни (по умолчанию 20 минут, настраивается через `AUTH_ACCESS_TOKEN_EXPIRE_SEC`).

**Особенности:**
- Короткое время жизни для безопасности
- Хранится в Redis с TTL равным времени жизни токена
- Содержит информацию о пользователе (id, role)
- Используется в заголовке `Authorization: Bearer {access_token}`

### Refresh Token

Refresh token используется для обновления пары токенов. Имеет длительное время жизни (по умолчанию 30 дней, настраивается через `AUTH_REFRESH_TOKEN_EXPIRE_SEC`).

**Особенности:**
- Долгое время жизни
- Хранится в Redis и базе данных
- Связан с сессией пользователя
- Используется через query параметр `?token={refresh_token}`

### Структура токена

JWT токен содержит следующие поля:

```json
{
  "type": "access" | "refresh",
  "sub": "user_uuid",
  "data": {
    "id": "user_uuid",
    "role": "user" | "admin" | "superuser"
  },
  "exp": 1234567890,
  "iat": 1234567890
}
```

- `type` - тип токена (ACCESS или REFRESH)
- `sub` - subject (UUID пользователя)
- `data` - дополнительные данные (для access token: id, role)
- `exp` - время истечения (Unix timestamp)
- `iat` - время создания (Unix timestamp)

### Валидация токенов

При каждом запросе токен проверяется:
1. Декодирование JWT с использованием `AUTH_JWT_MASTER_KEY`
2. Проверка наличия обязательных полей (type, sub, data, exp, iat)
3. Проверка наличия токена в Redis (для возможности отзыва)
4. Проверка типа токена (для access token - только ACCESS)

## Процесс аутентификации

### Регистрация

**POST** `/api/auth/v1/register`

1. Валидация данных (login, password, email)
2. Проверка, что регистрация не отключена
3. Хеширование пароля с использованием `APP_SALT`
4. Создание пользователя со статусом `NOT_VERIFIED`
5. Создание профиля пользователя

**Требования к login:**
- Минимум 6 символов, максимум 20
- Должен начинаться с буквы
- Может содержать буквы, цифры и подчеркивания

### Вход в систему

**POST** `/api/auth/v1/login`

1. Поиск пользователя по login
2. Проверка пароля
3. Создание сессии в базе данных
4. Генерация access token и refresh token
5. Сохранение токенов в Redis
6. Сохранение refresh token в базе данных
7. Ограничение количества активных сессий (удаление старых, если превышен лимит)

**Ответ:** Пара токенов (access и refresh)

### Обновление токенов

**POST** `/api/auth/v1/refresh`

1. Валидация refresh token
2. Проверка наличия в Redis и базе данных
3. Проверка активности refresh token
4. Создание новой пары токенов
5. Обновление сессии в базе данных
6. Сохранение новых токенов в Redis

**Ответ:** Новая пара токенов

### Выход из системы

**POST** `/api/auth/v1/logout`

1. Деактивация текущей сессии в базе данных
2. Деактивация refresh token в базе данных
3. Удаление access token из Redis
4. Удаление refresh token из Redis

## Хранение токенов

### Redis

Токены хранятся в Redis для быстрой проверки и возможности отзыва:

- **Access token:** ключ `{user_id}:{token}`, TTL = время жизни токена
- **Refresh token:** ключ `{user_id}:{token}`, TTL = время жизни токена

При валидации токена проверяется его наличие в Redis. Если токена нет - он считается недействительным.

### База данных

В базе данных хранятся:

- **Сессии (Session):** информация о каждой активной сессии пользователя
  - `session_token` - access token
  - `user_id` - ID пользователя
  - `user_agent`, `ip_address`, `device_info` - метаданные запроса
  - `expires_at` - время истечения
  - `last_activity` - последняя активность
  - `is_active` - статус активности

- **Refresh токены (RefreshToken):** долгоживущие токены для обновления
  - `token` - refresh token
  - `user_id` - ID пользователя
  - `session_id` - связь с сессией
  - `expires_at` - время истечения
  - `is_active` - статус активности

## Сессии

### Создание сессии

Сессия создается автоматически при входе в систему. В сессии сохраняется:
- Access token
- Метаданные запроса (User-Agent, IP адрес, информация об устройстве)
- Время создания и истечения
- Название сессии (автоматически определяется из User-Agent)

### Управление сессиями

Пользователь может:
- Просматривать список всех активных сессий
- Завершать конкретную сессию
- Завершать все сессии (с возможностью исключить текущую)

### Ограничение количества сессий

Система ограничивает количество одновременных активных сессий на пользователя (по умолчанию 3, настраивается через `AUTH_MAX_SESSIONS`).

При превышении лимита автоматически деактивируется самая старая сессия (по `last_activity`).

### Удаление истекших сессий

Администраторы могут запустить очистку истекших сессий через endpoint `/api/admin/v1/sessions/cleanup`. Система удаляет все сессии, у которых `expires_at` меньше текущего времени.

## Безопасность

### Хеширование паролей

Пароли хешируются с использованием алгоритма **PBKDF2-SHA256** с солью из `APP_SALT`.

**Процесс:**
1. К паролю добавляется соль (`password + APP_SALT`)
2. Применяется PBKDF2-SHA256
3. Хеш сохраняется в базе данных

**Верификация:**
1. К введенному паролю добавляется соль
2. Вычисляется хеш
3. Сравнивается с сохраненным хешем

### Rate Limiting

Система использует rate limiting для защиты от брутфорс атак:

- **Глобальный лимит:** применяется ко всем endpoints (настраивается через `RATE_LIMIT_DEFAULT_REQUESTS_PER_MINUTE`, по умолчанию 60 запросов в минуту)
- **Специальные лимиты:** для аутентификационных endpoints могут быть установлены более строгие лимиты
- **Исключения:** определенные IP адреса могут быть исключены из rate limiting (настраивается через `RATE_LIMIT_EXCLUDE_IP_ADDRESSES`)

При превышении лимита возвращается ошибка `rate_limit_error` (HTTP 429).

### Защита от атак

- **CORS:** настроен для разрешения запросов только с разрешенных доменов (настраивается через `APP_ALLOWED_DOMAINS`)
- **Security Headers:** автоматически добавляются security headers в ответы
- **Валидация токенов:** каждый токен проверяется на валидность и наличие в Redis
- **Отзыв токенов:** возможность немедленного отзыва токенов через удаление из Redis

### CORS настройки

CORS настроен для работы только с разрешенными доменами:

- `allow_origins` - список разрешенных доменов из `APP_ALLOWED_DOMAINS`
- `allow_credentials` - разрешены credentials (для работы с cookies)
- `allow_methods` - разрешенные методы: GET, POST, DELETE, PATCH, OPTIONS
- `allow_headers` - разрешенные заголовки: Authorization, Content-Type

## Социальная авторизация

### Поддерживаемые провайдеры

В настоящее время поддерживается только **Telegram** через Telegram WebApp.

### Процесс OAuth

**POST** `/api/auth/v1/login/social/telegram`

**Процесс авторизации через Telegram:**

1. **Валидация данных Telegram:**
   - Проверка hash параметра из `init_data` Telegram WebApp
   - Проверка подписи с использованием токена бота (`APP_TELEGRAM_BOT_TOKEN`)

2. **Поиск или создание пользователя:**
   - Поиск существующей связи социальной сети с пользователем
   - Если не найдено - создание нового пользователя:
     - Генерация случайного пароля
     - Создание login в формате `#telegram_{telegram_id}`
     - Создание профиля с данными из Telegram
     - Создание записи в таблице Social

3. **Создание сессии и токенов:**
   - Создание сессии с метаданными
   - Генерация пары токенов
   - Сохранение токенов в Redis и базе данных

**Требования к данным Telegram:**
- `id` - ID пользователя в Telegram
- `first_name` - имя пользователя
- `auth_date` - время авторизации
- `hash` - подпись для проверки подлинности
- Опционально: `last_name`, `username`, `photo_url`, `language_code`

**Безопасность:**
- Проверка подписи hash с использованием секретного ключа бота
- Использование `hmac.compare_digest` для защиты от timing attacks
- Валидация всех входящих данных
